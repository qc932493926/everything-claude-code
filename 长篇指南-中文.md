# Everything Claude Code 长篇指南

![头部：Everything Claude Code 长篇指南](./assets/images/longform/01-header.png)

---

> **前置条件**：本指南以 [Everything Claude Code 精简指南](./the-shortform-guide.md) 为基础。如果你还没有设置技能、钩子、子代理、MCP 和插件，请先阅读那个。

![对精简指南的参考](./assets/images/longform/02-shortform-reference.png)
*精简指南 - 先阅读它*

在精简指南中，我涵盖了基础设置：技能和命令、钩子、子代理、MCP、插件和形成有效 Claude Code 工作流骨干的配置模式。那是设置指南和基础设施。

这个长篇指南深入探讨了将生产会话与浪费会话分开的技术。如果你还没有阅读精简指南，请回去先设置你的配置。下面的内容假设你已经配置并正在使用技能、代理、钩子和 MCP。

这里的主题：Token 经济学、内存持久性、验证模式、并行化策略，以及构建可复用工作流的复合效应。这些是我在 10+ 个月的日常使用中完善的模式，使得在第一小时内从上下文腐烂困扰中受益，与能够维持数小时生产会话之间的区别。

精简指南和长篇指南中涵盖的所有内容都可在 GitHub 上获得：`github.com/affaan-m/everything-claude-code`

---

## 提示和技巧

### 某些 MCP 是可替代的，将释放你的上下文窗口

对于 MCP，如版本控制（GitHub）、数据库（Supabase）、部署（Vercel、Railway）等 - 这些平台中的大多数已经拥有强大的 CLI，MCP 基本上只是包装它们。MCP 是一个不错的包装器，但它有一个代价。

要让 CLI 的功能更像 MCP 而不实际使用 MCP（及其伴随的减少的上下文窗口），考虑将功能捆绑到技能和命令中。剥离 MCP 暴露的工具，使事情变得容易，并将其转换为命令。

示例：与其一直加载 GitHub MCP，不如创建一个 `/gh-pr` 命令，用你首选的选项包装 `gh pr create`。与其让 Supabase MCP 吃上下文，不如创建直接使用 Supabase CLI 的技能。

通过延迟加载，上下文窗口问题在很大程度上得到解决。但 Token 使用和成本不是以相同方式解决的。CLI + 技能方法仍然是 Token 优化方法。

---

## 重要内容

### 上下文和内存管理

对于跨会话共享内存，总结进度并检查的技能或命令，然后保存到你的 `.claude` 文件夹中的 `.tmp` 文件并附加到它，直到你的会话结束，是最好的方法。第二天它可以将其用作上下文并从中断处继续，为每个会话创建新文件以便你不污染旧上下文到新工作。

![会话存储文件树](./assets/images/longform/03-session-storage.png)
*会话存储的示例 -> https://github.com/affaan-m/everything-claude-code/tree/main/examples/sessions*

Claude 创建一个汇总当前状态的文件。审查它，根据需要要求编辑，然后开始新鲜。对于新对话，只需提供文件路径。当你达到上下文限制并需要继续复杂工作时特别有用。这些文件应该包含：
- 什么方法奏效（有证据可证实）
- 尝试但不起作用的方法
- 尚未尝试的方法以及剩下要做的事情

**策略地清除上下文：**

一旦你设定了你的计划并清除了上下文（Claude Code 中计划模式的默认选项），你可以从计划工作。当你累积了大量不再相关于执行的探索上下文时这很有用。对于策略性压缩，禁用自动压缩。在逻辑间隔处手动压缩或创建为你执行的技能。

**高级：动态系统提示注入**

我学到的一个模式：与其只将所有内容放在 CLAUDE.md（用户范围）或 `.claude/rules/`（项目范围）中（每个会话加载），不如使用 CLI 标志动态注入上下文。

```bash
claude --system-prompt "$(cat memory.md)"
```

这让你对什么上下文何时加载更加精确。系统提示内容比用户消息具有更高的权限，用户消息比工具结果具有更高的权限。

**实际设置：**

```bash
# 日常开发
alias claude-dev='claude --system-prompt "$(cat ~/.claude/contexts/dev.md)"'

# PR 审查模式
alias claude-review='claude --system-prompt "$(cat ~/.claude/contexts/review.md)"'

# 研究/探索模式
alias claude-research='claude --system-prompt "$(cat ~/.claude/contexts/research.md)"'
```

**高级：内存持久性钩子**

有大多数人不知道的钩子可帮助内存：

- **PreCompact Hook**：在上下文压缩发生之前，将重要状态保存到文件
- **Stop Hook（会话结束）**：会话结束时，将学习持久化到文件
- **SessionStart Hook**：新会话时，自动加载之前的上下文

我构建了这些钩子，它们在 `github.com/affaan-m/everything-claude-code/tree/main/hooks/memory-persistence` 中的存储库中

---

### 持续学习/内存

如果你必须多次重复一个提示，Claude 遇到了相同的问题或给你一个你以前听过的响应 - 这些模式必须附加到技能中。

**问题：** 浪费的 Token，浪费的上下文，浪费的时间。

**解决方案：** 当 Claude Code 发现不平凡的东西时 - 调试技巧、变通方法、某些项目特定的模式 - 它将该知识保存为新技能。下次出现类似问题时，技能会自动加载。

我构建了一个持续学习技能来做到这一点：`github.com/affaan-m/everything-claude-code/tree/main/skills/continuous-learning`

**为什么是 Stop Hook（不是 UserPromptSubmit）：**

关键的设计决策是使用 **Stop hook** 而不是 UserPromptSubmit。UserPromptSubmit 在每条消息上运行 - 为每个提示添加延迟。Stop 在会话结束时运行一次 - 轻量级，不会在会话中减速你。

---

### Token 优化

**主要策略：子代理架构**

优化你使用的工具和子代理架构设计为委派足够任务的最便宜可能模型。

**模型选择快速参考：**

![模型选择表](./assets/images/longform/04-model-selection.png)
*假设各种常见任务子代理的设置和选择理由*

| 任务类型 | 模型 | 原因 |
|---------|------|------|
| 探索/搜索 | Haiku | 快速、便宜、足以找到文件 |
| 简单编辑 | Haiku | 单文件更改、清晰的说明 |
| 多文件实现 | Sonnet | 编码的最佳平衡 |
| 复杂架构 | Opus | 需要深思熟虑 |
| PR 审查 | Sonnet | 理解上下文、捕捉细微差别 |
| 安全分析 | Opus | 不能错过漏洞 |
| 写文档 | Haiku | 结构很简单 |
| 调试复杂的 Bug | Opus | 需要在脑海中保留整个系统 |

对 90% 的编码任务默认使用 Sonnet。当第一次尝试失败、任务跨越 5+ 个文件、架构决策或安全关键代码时升级到 Opus。

**定价参考：**

![Claude 模型定价](./assets/images/longform/05-pricing-table.png)
*来源：https://platform.claude.com/docs/en/about-claude/pricing*

**工具特定优化：**

用 mgrep 替换 grep - 与传统 grep 或 ripgrep 相比平均减少 ~50% 的 Token：

![mgrep 基准](./assets/images/longform/06-mgrep-benchmark.png)
*在我们 50 任务基准中，mgrep + Claude Code 使用 ~2 倍更少的 Token，质量相似或更好。来源：https://github.com/mixedbread-ai/mgrep*

**模块化代码库的好处：**

拥有更模块化的代码库，主文件为数百行而不是数千行有助于 Token 优化成本和第一次正确完成任务。

---

### 验证循环和评估

**基准工作流：**

比较用和不用技能问同样的事，检查输出差异：

Fork 对话，在其中一个没有技能的新 worktree 中启动，最后提取差异，查看记录了什么。

**评估模式类型：**

- **基于检查点的评估**：设置明确的检查点，针对定义的标准进行验证，修复后再继续
- **持续评估**：每 N 分钟或重大变更后运行，完整的测试套件 + lint

**关键指标：**

```
pass@k：至少 k 次尝试中的一次成功
        k=1: 70%  k=3: 91%  k=5: 97%

pass^k：所有 k 次尝试都必须成功
        k=1: 70%  k=3: 34%  k=5: 17%
```

当你只需要它工作时使用 **pass@k**。当一致性至关重要时使用 **pass^k**。

---

## 并行化

在多 Claude 终端设置中 fork 对话时，确保 fork 中的操作范围和原始对话都明确定义。在代码变更方面目标是最小的重叠。

**我的首选模式：**

代码变更的主聊天，fork 用于关于代码库及其当前状态的问题或外部服务的研究。

**关于任意终端计数：**

![Boris 关于并行终端](./assets/images/longform/07-boris-parallel.png)
*Boris（Anthropic）关于运行多个 Claude 实例*

Boris 有关于并行化的提示。他建议了运行 5 个 Claude 实例本地和 5 个上游等事情。我建议反对设置任意终端数量。终端的添加应该出于真正的必要。

你的目标应该是：**用最小可行的并行化数量你能完成多少。**

**用于并行实例的 Git Worktrees：**

```bash
# 为并行工作创建 worktrees
git worktree add ../project-feature-a feature-a
git worktree add ../project-feature-b feature-b
git worktree add ../project-refactor refactor-branch

# 每个 worktree 获取自己的 Claude 实例
cd ../project-feature-a && claude
```

如果你要开始扩展你的实例，并且你有多个 Claude 实例处理彼此重叠的代码，那么使用 git worktrees 并为每个制定非常明确的计划至关重要。使用 `/rename <name here>` 命名所有你的聊天。

![两终端设置](./assets/images/longform/08-two-terminals.png)
*启动设置：左终端用于编码，右终端用于问题 - 使用 /rename 和 /fork*

**级联方法：**

运行多个 Claude Code 实例时，用"级联"模式组织：

- 在新标签中的右边打开新任务
- 从左到右扫，最旧到最新
- 一次最多专注于 3-4 个任务

---

## 基础工作

**两实例启动模式：**

对于我自己的工作流管理，我喜欢用 2 个打开的 Claude 实例启动空存储库。

**实例 1：脚手架代理**
- 放下脚手架和基础工作
- 创建项目结构
- 设置配置（CLAUDE.md、规则、代理）

**实例 2：深度研究代理**
- 连接到所有你的服务、网络搜索
- 创建详细的 PRD
- 创建架构 mermaid 图
- 用实际文档片段编译参考

**llms.txt 模式：**

如果可用，你可以通过在达到其文档页面后对其进行 `/llms.txt` 来在许多文档参考上找到 `llms.txt`。这为你提供了文档的干净、LLM 优化版本。

**哲学：构建可复用模式**

来自 @omarsar0："早期，我花时间构建可复用的工作流/模式。构建很繁琐，但这对模型和代理工具改进有野生复合效应。"

**要投资什么：**

- 子代理
- 技能
- 命令
- 规划模式
- MCP 工具
- 上下文工程模式

---

## 代理和子代理的最佳实践

**子代理上下文问题：**

子代理存在以通过返回摘要而不是倾倒所有东西来节省上下文。但编排器拥有子代理缺乏的语义上下文。子代理只知道字面查询，不知道请求背后的目的。

**迭代检索模式：**

1. 编排器评估每个子代理返回
2. 在接受前提出后续问题
3. 子代理回到源，获得答案，返回
4. 循环直到充分（最多 3 个周期）

**关键：** 传递目标上下文，不只是查询。

**带有顺序阶段的编排器：**

```markdown
第 1 阶段：研究（使用 Explore 代理）→ research-summary.md
第 2 阶段：计划（使用规划代理）→ plan.md
第 3 阶段：实现（使用 tdd-guide 代理）→ 代码变更
第 4 阶段：审查（使用 code-reviewer 代理）→ review-comments.md
第 5 阶段：验证（如需要使用 build-error-resolver）→ 完成或循环回
```

**关键规则：**

1. 每个代理获得一个清晰的输入并产生一个清晰的输出
2. 输出成为下一阶段的输入
3. 永远不要跳过阶段
4. 在代理间使用 `/clear`
5. 将中间输出存储在文件中

---

## 有趣的内容/不关键只是有趣的提示

### 自定义状态行

你可以使用 `/statusline` 设置它 - 然后 Claude 会说你没有一个但可以为你设置它并询问你想要什么。

另见：https://github.com/sirmalloc/ccstatusline

### 语音转录

用你的声音与 Claude Code 交谈。对许多人来说比打字更快。

- superwhisper、MacWhisper 在 Mac 上
- 即使有转录错误，Claude 也理解意图

### 终端别名

```bash
alias c='claude'
alias gb='github'
alias co='code'
alias q='cd ~/Desktop/projects'
```

---

## 里程碑

![25k+ GitHub 星](./assets/images/longform/09-25k-stars.png)
*不到一周内 25,000+ GitHub 星*

---

## 资源

**代理编排：**

- https://github.com/ruvnet/claude-flow - 拥有 54+ 专业代理的企业编排平台

**自我改进内存：**

- https://github.com/affaan-m/everything-claude-code/tree/main/skills/continuous-learning
- rlancemartin.github.io/2025/12/01/claude_diary/ - 会话反射模式

**系统提示参考：**

- https://github.com/x1xhlol/system-prompts-and-models-of-ai-tools - 系统提示集合（110k 星）

**官方：**

- Anthropic Academy：anthropic.skilljar.com

---

## 参考资料

- [Anthropic：揭示 AI 代理的评估](https://www.anthropic.com/engineering/demystifying-evals-for-ai-agents)
- [YK：32 Claude Code 技巧](https://agenticcoding.substack.com/p/32-claude-code-tips-from-basics-to)
- [RLanceMartin：会话反射模式](https://rlancemartin.github.io/2025/12/01/claude_diary/)
- @PerceptualPeak：子代理上下文协商
- @menhguin：代理抽象分级
- @omarsar0：复合效应哲学

---

*精简和长篇指南中涵盖的所有内容都可在 GitHub 上的 [everything-claude-code](https://github.com/affaan-m/everything-claude-code) 获得*
